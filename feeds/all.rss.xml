<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>dtsomp's blog</title><link>https://blog.dtsomp.net/</link><description>No keyboards were harmed during the making of this site.</description><lastBuildDate>Wed, 19 Sep 2018 00:00:00 +0200</lastBuildDate><item><title>Distributing certificates with Hiera</title><link>https://blog.dtsomp.net/distributing-certificates-with-hiera.html</link><description>&lt;h2&gt;Short intro&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://puppet.com/docs/puppet/5.3/hiera_intro.html"&gt;Hiera&lt;/a&gt; is what you should use to get data into Puppet's variables. &lt;a href="https://puppet.com/blog/encrypt-your-data-using-hiera-eyaml"&gt;Hiera-eyaml&lt;/a&gt; is what you should use to make sure that data is encrypted when in rest (i.e. committed in a repository).&lt;/p&gt;
&lt;p&gt;If you don't need to encrypt certificates (or other files) in a repository, then this article is not for you.&lt;/p&gt;
&lt;p&gt;Why would you need to distribute certificates instead of creating them on the hosts themselves?
There are a couple of reasons. 
In my case it was a certificate provided by a third-party.
I am sure there are more use cases for this.&lt;/p&gt;
&lt;h2&gt;Plain-text certificates&lt;/h2&gt;
&lt;p&gt;My biggest dislike about Hiera is the way that everything it handles is plain text. I mean, not dislike per se - everybody loves plain text, right? - but there is the issue of distributing files, like certificates.&lt;/p&gt;
&lt;p&gt;PEM files are fine, they are already plain text. The way to handle them is to encrypt them:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ eyaml encrypt -n gpg --gpg-recipients-file hiera-eyaml-gpg.recipients -f snakeoil.pem

string: ENC&lt;span class="o"&gt;[&lt;/span&gt;GPG,hQEMAzQwoE+Gwj0aAQf+JbeDfSzWqt+xNP109+w+JENeIBn34D7s7...

OR
block: &amp;gt;
    ENC&lt;span class="o"&gt;[&lt;/span&gt;GPG,hQEMAzQwoE+Gwj0aAQf+JbeDfSzWqt+xNP109+w+JENeIBn34D7s7wyYbaaS
    ocKN1/jk5TUTlmURnNz/Da7mMZfMiVGlGBni8MJQer7PTvWApVzo1lHtdQF/
    WTJvfp9pHOQ5XncYm7DXi8ZJnbQujFAXFzieUnEaavBZBFeNoXuCH92rbnLP
    f3oKQwEQetH4YEYvUxgmZl1Ww98rBL6m72LNZ+TG6iOM7dIgx2RWWT4Z0//G
    fNr2Sz3iU2243xtKA6hoRvlJzBOKPBvsoK8iDFd425Wo2gp54fG27fcQMT/I
    ....
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and then append one of the two forms to your eyaml file. The block format is usually sliiiiightly more readable.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cert::snakeoil_pem: &amp;gt;
ENC[GPG,hQEMAzQwoE+Gwj0aAQf+JbeDfSzWqt+xNP109+w+JENeIBn34D7s7wyYbaaS
    ocKN1/jk5TUTlmURnNz/Da7mMZfMiVGlGBni8MJQer7PTvWApVzo1lHtdQF/
    WTJvfp9pHOQ5XncYm7DXi8ZJnbQujFAXFzieUnEaavBZBFeNoXuCH92rbnLP
    f3oKQwEQetH4YEYvUxgmZl1Ww98rBL6m72LNZ+TG6iOM7dIgx2RWWT4Z0//G
    fNr2Sz3iU2243xtKA6hoRvlJzBOKPBvsoK8iDFd425Wo2gp54fG27fcQMT/I
    ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then you can recreate the file on the Puppet host.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# puppet
file{&amp;#39;snakeoil.pem&amp;#39;:
    content =&amp;gt; looukup(&amp;#39;cert::snakeoil_pem&amp;#39;)
    ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is not an elegant solution. If you use &lt;code&gt;hiera-eyaml-gpg&lt;/code&gt; (like we do), this text block is going to get huge.&lt;/p&gt;
&lt;h2&gt;Binary certificates&lt;/h2&gt;
&lt;p&gt;If, however, you have to deal with a binary format (eg .p12), then there's an extra problem to deal with. &lt;code&gt;hiera-eyaml&lt;/code&gt; et al seem to handle binary files pretty well. 
Hiera on the other hand seems to throw a hissy fit when it comes to reading variables containing binary.&lt;/p&gt;
&lt;p&gt;When in doubt, &lt;code&gt;base64&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ base64 snakeoil.p12 &lt;span class="p"&gt;|&lt;/span&gt; eyaml encrypt -n gpg --gpg-recipients hiera-eyaml-gpg.recipients --stdin

string: ENC&lt;span class="o"&gt;[&lt;/span&gt;GPG,hQEMAzQwoE+Gwj0aAQf+JbeDfSzWqt+xNP109+w+JENeIBn34D7s7wy...

OR
block: &amp;gt;
    ENC&lt;span class="o"&gt;[&lt;/span&gt;GPG,hQEMAzQwoE+Gwj0aAQf+JbeDfSzWqt+xNP109+w+JENeIBn34D7s7wyYbaaS
    ocKN1/jk5TUTlmURnNz/Da7mMZfMiVGlGBni8MJQer7PTvWApVzo1lHtdQF/
    WTJvfp9pHOQ5XncYm7DXi8ZJnbQujFAXFzieUnEaavBZBFeNoXuCH92rbnLP
    f3oKQwEQetH4YEYvUxgmZl1Ww98rBL6m72LNZ+TG6iOM7dIgx2RWWT4Z0//G
    fNr2Sz3iU2243xtKA6hoRvlJzBOKPBvsoK8iDFd425Wo2gp54fG27fcQMT/I
    ....
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Insert in your eyaml file as usual. When it's time to retrieve the certificate, don't forget to Base64-decode it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;file{&amp;#39;snakeoil_p12&amp;#39;:
    content =&amp;gt; base64(&amp;#39;decode&amp;#39;, looukup(&amp;#39;cert::snakeoil_p12&amp;#39;))
    ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That's not fun by any standard, but it works.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dtsomp</dc:creator><pubDate>Wed, 19 Sep 2018 00:00:00 +0200</pubDate><guid isPermaLink="false">tag:blog.dtsomp.net,2018-09-19:/distributing-certificates-with-hiera.html</guid></item><item><title>Automated Pelican builds on Github Pages</title><link>https://blog.dtsomp.net/automated-pelican-builds-on-github-pages.html</link><description>&lt;p&gt;I am not a huge user of Github, mainly because there is very little code I feel comfortable sharing with others.
However, excuses are needed to try out new stuff, so I set up this blog on &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Github Pages (GhP in short) is a fancy name for repositories marked for HTML hosting.
Even free accounts get one, so go ahead and create a new repository called &lt;code&gt;username.github.io&lt;/code&gt;, replacing &lt;code&gt;username&lt;/code&gt; with your Github username.
E.g. in my case my GhP repo is called &lt;a href="https://github.com/dtsomp/dtsomp.github.io"&gt;dtsomp.github.io&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Just add an &lt;code&gt;index.html&lt;/code&gt;, commit and push to it.
Congratulations, your new website is avaiable on https://username.github.io.&lt;/p&gt;
&lt;p&gt;Now for the really interesting stuff.&lt;/p&gt;
&lt;p&gt;I couldn't create decent-looking HTML pages to save my life and this is why I'm toying around with &lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt; for generating my blog pages.
I could use Pelican's (rather under-documented) publish functionality to push my content to GhP or just copy-paste the generated HTML files into my local copy of the repo and commit-push.&lt;/p&gt;
&lt;p&gt;Or I could have &lt;a href="https://travis-ci.com/"&gt;Travis CI&lt;/a&gt; do this for me.&lt;/p&gt;
&lt;p&gt;So here's the setup:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a GhP repo for hosting the final HTML files.&lt;/li&gt;
&lt;li&gt;a Github token for commiting to this repo.&lt;/li&gt;
&lt;li&gt;a &lt;a href="https://github.com/dtsomp/blog"&gt;source repo&lt;/a&gt; which tracks the original Pelican project directory of the blog, containing source files, publishing configuration etc.&lt;/li&gt;
&lt;li&gt;Travis CI triggering builds after every push to the source repo and using the token to update the GhP repo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instructions below are in no way intended to serve as notes for my absent-minded self. No sir. Nuh-uh.&lt;/p&gt;
&lt;p&gt;First step, create the repository for your blog's source code. 
Add all of your code, then add the following files at the root of the directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dtsomp/blog/blob/master/requirements.txt"&gt;requirements.txt&lt;/a&gt;, contains the Python modules required by Pelican for generating the HTML pages.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dtsomp/blog/blob/master/.travis.yml"&gt;.travis.yml&lt;/a&gt;, contains the steps that Travis needs to take.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dtsomp/blog/blob/master/deploy.sh"&gt;deploy.sh&lt;/a&gt; is the script called in the last step of &lt;code&gt;.travis.yml&lt;/code&gt;, it copies the generated HTML files to the GhP repo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Important: make sure you update &lt;code&gt;TARGET_REPO&lt;/code&gt; in &lt;code&gt;deploy.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Regarding the token, you can generate it in your Github's profile &lt;a href="https://github.com/settings/tokens"&gt;personal access tokens page&lt;/a&gt;.
Click on "&lt;em&gt;Generate new token&lt;/em&gt;", add a description (something like "blog-ci-token") and I would advise enabling only the following scopes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;repo:status&lt;/li&gt;
&lt;li&gt;repo_deployment&lt;/li&gt;
&lt;li&gt;public_repo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once it's generated, you'll get a long string, e.g. "73e3b4e29bd10e3af8f4c3b9cb0f949622f07e24".
Copy it, you'll need it later on.
(I should point out that this is a random string, not an actual token of mine :P)&lt;/p&gt;
&lt;p&gt;Now go to &lt;a href="https://travis-ci.com"&gt;https://travis-ci.com&lt;/a&gt; and hook it up to your Github account. 
The requirement here is that Travis is enabled for the repository that contains the blog source.&lt;/p&gt;
&lt;p&gt;The repo will show up in your Travis CI profile. Hit the Settings button for it.&lt;/p&gt;
&lt;p&gt;&lt;img alt="travis ci profile" src="/images/2018/travis-ci-profile.png"&gt;&lt;/p&gt;
&lt;p&gt;Scroll down to Enviromental Variables, add a new one named "GITHUB_TOKEN" and use the token string as value. 
"Display value in build log" should OFF.
You could use a different name instead of GITHUB_TOKEN, just make sure that &lt;code&gt;deploy.sh&lt;/code&gt; is updated accordingly.&lt;/p&gt;
&lt;p&gt;At this point, you &lt;em&gt;should&lt;/em&gt; be ready to go. 
Pushing to your source repo should trigger a Travis build, generate the HTML content and push it to your page repo.&lt;/p&gt;
&lt;p&gt;That's it!&lt;/p&gt;
&lt;p&gt;&lt;s&gt;Sites where I stole content from&lt;/s&gt; &lt;strong&gt;References&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://serge-m.github.io/set-up-travis-ci-for-building-personal-page-on-github-pages-with-pelican.html"&gt;Set up Travis CI for building personal page on Github Pages with Pelican&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zonca.github.io/2013/09/automatically-build-pelican-and-publish-to-github-pages.html"&gt;How to automatically build your Pelican blog and publish it to Github Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dtsomp</dc:creator><pubDate>Sat, 18 Aug 2018 00:00:00 +0200</pubDate><guid isPermaLink="false">tag:blog.dtsomp.net,2018-08-18:/automated-pelican-builds-on-github-pages.html</guid></item><item><title>Hello world</title><link>https://blog.dtsomp.net/hello-world.html</link><description>&lt;p&gt;My personal blog has not been updated for so long, it might as well be dead.
With that in mind, I've decided to try out something new and go for a custom domain and a new blog engine.&lt;/p&gt;
&lt;p&gt;If you're reading this, then you already know the new domain :)&lt;/p&gt;
&lt;p&gt;To get the blog up and running, I've opted for &lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;, a Python-based static site generator.
I think that static pages are a perfect fit for blogs and I really, really, REALLY wanted to move away the Blogger platform.
The choice of engine itself is a bit random, I don't really have any experience of static site generators, so I just picked one that seemed to fit the bill.
It's part of the whole experiment, really.&lt;/p&gt;
&lt;p&gt;I'll attempt to host this on &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On the plus side, I get to use Vim to edit posts. &lt;/p&gt;
&lt;p&gt;Here's hoping things work out.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dtsomp</dc:creator><pubDate>Sat, 11 Aug 2018 00:00:00 +0200</pubDate><guid isPermaLink="false">tag:blog.dtsomp.net,2018-08-11:/hello-world.html</guid></item></channel></rss>